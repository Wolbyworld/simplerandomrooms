<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Draw Room - Vibecoded</title>
    <link rel="stylesheet" href="{{ url_for('static', path='css/styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', path='css/room.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', path='css/counter.css') }}">
    <link rel="icon" href="{{ url_for('static', path='favicon.svg') }}" type="image/svg+xml">
    <link rel="alternate icon" href="{{ url_for('static', path='favicon.ico') }}" type="image/x-icon">
</head>
<body>
    <div class="container room-container">
        <header>
            <div class="home-link">
                <a href="/" class="back-link">‚Üê Back to Home</a>
                <button id="theme-toggle" class="theme-toggle" aria-label="Toggle dark mode">
                    <span class="theme-toggle-icon">üåô</span>
                </button>
            </div>
            <h1>Random Draw Room</h1>
            <div id="user-display">
                <div class="user-count">
                    <span id="user-count-value">0</span> participants
                </div>
                <div class="user-pills" id="user-pills"></div>
            </div>
        </header>

        <div class="share-box">
            <input type="text" id="room-url" value="{{ request.url }}" readonly>
            <button id="copy-url-btn">Copy URL</button>
        </div>
        
        <main>
            {% if room.is_coin_flip %}
                <div class="action-box coin-flip-box">
                    <h2>Coin Flip</h2>
                    <div class="coin-container">
                        <div class="coin" id="coin">
                            <div class="heads"></div>
                            <div class="tails"></div>
                        </div>
                    </div>
                    <div class="participants-progress-container">
                        <div class="participants-progress">
                            <div class="progress-bar"><div id="progress-fill" class="progress-fill"></div></div>
                            <div class="progress-text"><span id="current-participants">1</span>/2 participants</div>
                        </div>
                        <p class="invite-prompt">Share the URL above to invite friends!</p>
                    </div>
                    <button id="flip-coin-btn" disabled>Flip Coin</button>
                    <button id="demo-mode-btn" class="demo-mode-btn">Quick Start (Demo Mode)</button>
                    <p id="not-enough-users" class="warning">At least 2 participants required</p>
                </div>
            {% elif room.is_list_draw %}
                <div class="action-box list-draw-box">
                    <h2>List Draw</h2>
                    <div id="list-params-form">
                        <div class="form-group textarea-group">
                            <label for="list-items">Enter items (one per line):</label>
                            <textarea id="list-items" name="list_items" rows="6" placeholder="Item 1&#10;Item 2&#10;Item 3" required></textarea>
                        </div>
                        <div class="form-group checkbox-group">
                            <input type="checkbox" id="with-replacement" name="with_replacement" {% if room.with_replacement %}checked{% endif %}>
                            <label for="with-replacement">Replacement <span class="tooltip-trigger">?<span class="tooltip-text">When enabled, items can be drawn multiple times. When disabled, each item can only be drawn once.</span></span></label>
                        </div>
                    </div>
                    
                    <div class="list-result">
                        <div class="list-display" id="list-display">?</div>
                    </div>
                    
                    <div class="participants-progress-container">
                        <div class="participants-progress">
                            <div class="progress-bar"><div id="progress-fill" class="progress-fill"></div></div>
                            <div class="progress-text"><span id="current-participants">1</span>/2 participants</div>
                        </div>
                        <p class="invite-prompt">Share the URL above to invite friends!</p>
                    </div>
                    
                    <button id="draw-list-btn" disabled>Draw Item</button>
                    <button id="demo-mode-btn" class="demo-mode-btn">Quick Start (Demo Mode)</button>
                    <p id="not-enough-users" class="warning">At least 2 participants required</p>
                </div>
            {% else %}
                <div class="action-box number-draw-box">
                    <h2>Number Draw</h2>
                    <div id="number-params-form">
                        <div class="form-group">
                            <label for="min-value">Min value:</label>
                            <input type="number" id="min-value" name="min_value" value="{{ room.min_value }}" required>
                        </div>
                        <div class="form-group">
                            <label for="max-value">Max value:</label>
                            <input type="number" id="max-value" name="max_value" value="{{ room.max_value }}" required>
                        </div>
                        <div class="form-group checkbox-group">
                            <input type="checkbox" id="with-replacement" name="with_replacement" {% if room.with_replacement %}checked{% endif %}>
                            <label for="with-replacement">Replacement <span class="tooltip-trigger">?<span class="tooltip-text">When enabled, numbers can be drawn multiple times. When disabled, each number can only be drawn once.</span></span></label>
                        </div>
                    </div>
                    
                    <div class="number-result">
                        <div class="number-display" id="number-display">?</div>
                    </div>
                    
                    <div class="participants-progress-container">
                        <div class="participants-progress">
                            <div class="progress-bar"><div id="progress-fill" class="progress-fill"></div></div>
                            <div class="progress-text"><span id="current-participants">1</span>/2 participants</div>
                        </div>
                        <p class="invite-prompt">Share the URL above to invite friends!</p>
                    </div>
                    
                    <button id="draw-number-btn" disabled>Draw Number</button>
                    <button id="demo-mode-btn" class="demo-mode-btn">Quick Start (Demo Mode)</button>
                    <p id="not-enough-users" class="warning">At least 2 participants required</p>
                </div>
            {% endif %}

            <div class="history-box">
                <h2>Activity Log</h2>
                <div id="activity-log" class="activity-log"></div>
            </div>
        </main>

        <footer>
            <div class="footer-text">
                <p>Vibecoded in 2025</p>
            </div>
            <div class="counter-container">
                <div class="counter">
                    <span id="roomsCounter">0</span> rooms created
                </div>
                <div class="counter">
                    <span id="drawsCounter">0</span> draws performed
                </div>
            </div>
        </footer>
    </div>

    <script>
        // Store room data
        const roomId = "{{ room_id }}";
        const isCoinFlip = {% if room.is_coin_flip %}true{% else %}false{% endif %};
        const isListDraw = {% if room.is_list_draw %}true{% else %}false{% endif %};
        const clientId = Date.now().toString() + Math.random().toString(36).substring(2, 15);
        
        // Initialize state variables
        let isConnected = false;
        let users = [];
        let page = 0;
        let hasMoreLogs = true;
        let isLoadingLogs = false;
        let isDemoMode = false;
        
        // DOM elements
        const userCountElement = document.getElementById('user-count-value');
        const currentParticipantsEl = document.getElementById('current-participants');
        const progressFillEl = document.getElementById('progress-fill');
        const userPillsElement = document.getElementById('user-pills');
        const activityLog = document.getElementById('activity-log');
        const copyUrlBtn = document.getElementById('copy-url-btn');
        const roomUrlInput = document.getElementById('room-url');
        const demoModeBtn = document.getElementById('demo-mode-btn');
        const themeToggle = document.getElementById('theme-toggle');
        
        // Initialize theme based on user preference
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeToggleIcon(savedTheme);
        }
        
        // Update theme toggle icon based on current theme
        function updateThemeToggleIcon(theme) {
            const icon = themeToggle.querySelector('.theme-toggle-icon');
            icon.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }
        
        // Toggle between light and dark themes
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeToggleIcon(newTheme);
        }
        
        // Theme toggle event listener
        themeToggle.addEventListener('click', toggleTheme);
        
        // Initialize theme on page load
        initTheme();
        
        // Function to update participant progress bar
        function updateParticipantProgress() {
            const count = users.length;
            userCountElement.textContent = count;
            currentParticipantsEl.textContent = count;
            
            // Calculate progress percentage (max 100%)
            const progressPercentage = Math.min((count / 2) * 100, 100);
            progressFillEl.style.width = `${progressPercentage}%`;
            
            // Update button states
            updateButtonStates();
        }
        
        // Demo mode functionality
        demoModeBtn.addEventListener('click', function() {
            isDemoMode = !isDemoMode; // Toggle demo mode state
            
            if (isDemoMode) {
                // Activate demo mode
                demoModeBtn.classList.add('active');
                demoModeBtn.textContent = 'Exit Demo Mode';
                
                // Add demo indicator to page if it doesn't exist
                if (!document.querySelector('.demo-indicator')) {
                    const demoIndicator = document.createElement('div');
                    demoIndicator.className = 'demo-indicator';
                    demoIndicator.textContent = 'DEMO MODE';
                    document.querySelector('.action-box').appendChild(demoIndicator);
                }
                
                // Add to activity log
                addLogEntry({
                    timestamp: new Date().toISOString(),
                    action: 'demo_mode_activated',
                    user_id: clientId,
                    user_name: 'You'
                });
            } else {
                // Deactivate demo mode
                demoModeBtn.classList.remove('active');
                demoModeBtn.textContent = 'Quick Start (Demo Mode)';
                
                // Remove demo indicator
                const indicator = document.querySelector('.demo-indicator');
                if (indicator) {
                    indicator.remove();
                }
                
                // Add to activity log
                addLogEntry({
                    timestamp: new Date().toISOString(),
                    action: 'demo_mode_deactivated',
                    user_id: clientId,
                    user_name: 'You'
                });
            }
            
            // Update button states
            updateButtonStates();
        });
        
        // Function to update button states based on participant count or demo mode
        function updateButtonStates() {
            const buttons = isCoinFlip ? [flipCoinBtn] : isListDraw ? [drawListBtn] : [drawNumberBtn];
            
            buttons.forEach(btn => {
                if (isDemoMode || users.length >= 2) {
                    btn.disabled = false;
                    document.getElementById('not-enough-users').style.display = 'none';
                } else {
                    btn.disabled = true;
                    document.getElementById('not-enough-users').style.display = 'block';
                }
            });
        }
        
        {% if room.is_coin_flip %}
            const flipCoinBtn = document.getElementById('flip-coin-btn');
            const coinElement = document.getElementById('coin');
        {% elif room.is_list_draw %}
            const drawListBtn = document.getElementById('draw-list-btn');
            const listDisplay = document.getElementById('list-display');
            const listItemsTextarea = document.getElementById('list-items');
            const withReplacementCheckbox = document.getElementById('with-replacement');
            
            // List items array to track drawn items for non-replacement mode
            let listItems = [];
            let drawnItems = [];
            
            // Function to update list items from textarea
            function updateListItems() {
                const text = listItemsTextarea.value.trim();
                // Split by newline and filter out empty items
                listItems = text.split('\n').filter(item => item.trim() !== '');
                // Reset drawn items
                drawnItems = [];
            }
            
            // Initial update
            listItemsTextarea.addEventListener('change', updateListItems);
            
            // Send list items update to all clients
            listItemsTextarea.addEventListener('change', function() {
                if (isConnected && listItems.length > 0) {
                    socket.send(JSON.stringify({
                        type: 'list_draw',
                        list_items: listItems,
                        with_replacement: withReplacementCheckbox.checked,
                        drawn_items: drawnItems,
                        action: 'update_only' // Just update the list, don't perform a draw
                    }));
                }
            });
            
            // List draw animation
            function performListDrawAnimation(result) {
                listDisplay.className = 'list-display';
                void listDisplay.offsetWidth; // Force reflow
                
                listDisplay.textContent = result;
                listDisplay.className = 'list-display list-reveal';
            }
            
            // Handle list draw button
            drawListBtn.addEventListener('click', () => {
                if (isConnected) {
                    // Update list items first
                    updateListItems();
                    
                    if (listItems.length === 0) {
                        alert('Please enter at least one item in the list');
                        return;
                    }
                    
                    // Send draw request containing list items and parameters
                    socket.send(JSON.stringify({
                        type: 'list_draw',
                        list_items: listItems,
                        with_replacement: withReplacementCheckbox.checked,
                        drawn_items: drawnItems
                    }));
                }
            });
        {% else %}
            const drawNumberBtn = document.getElementById('draw-number-btn');
            const numberDisplay = document.getElementById('number-display');
            const minValueInput = document.getElementById('min-value');
            const maxValueInput = document.getElementById('max-value');
            const withReplacementCheckbox = document.getElementById('with-replacement');
            
            // Auto-save parameters when they change
            minValueInput.addEventListener('change', updateParameters);
            maxValueInput.addEventListener('change', updateParameters);
            withReplacementCheckbox.addEventListener('change', updateParameters);
            
            // Function to update parameters on the server
            async function updateParameters() {
                if (!isConnected) return;
                
                const minValue = parseInt(minValueInput.value);
                const maxValue = parseInt(maxValueInput.value);
                
                // Validate parameters
                if (minValue >= maxValue) {
                    alert("Minimum value must be less than maximum value");
                    return;
                }
                
                const formData = new FormData();
                formData.append('min_value', minValue);
                formData.append('max_value', maxValue);
                formData.append('with_replacement', withReplacementCheckbox.checked);
                
                try {
                    const response = await fetch(`/room/${roomId}/update-params`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        console.error(`Error: ${error.detail}`);
                    } else {
                        console.log('Parameters updated successfully:', {
                            min_value: minValue,
                            max_value: maxValue,
                            with_replacement: withReplacementCheckbox.checked
                        });
                    }
                } catch (error) {
                    console.error('Error updating parameters:', error);
                }
            }
        {% endif %}
        
        // WebSocket connection
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/room/${roomId}?client_id=${clientId}`;
        let socket;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 10;
        
        function connectWebSocket() {
            console.log('Attempting WebSocket connection to:', wsUrl);
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function(e) {
                console.log('WebSocket connection established');
                isConnected = true;
                reconnectAttempts = 0; // Reset reconnect counter on successful connection
                
                // Load initial logs
                loadLogs();
                
                // Add to activity log (only visible to current user)
                addLogEntry("Connection established");
            };
            
            socket.onmessage = function(event) {
                const message = JSON.parse(event.data);
                console.log('Message received:', message);
                
                switch(message.type) {
                    case 'join':
                        handleJoin(message);
                        break;
                    case 'leave':
                        handleLeave(message);
                        break;
                    case 'name_change':
                        handleNameChange(message);
                        break;
                    case 'random_action':
                        handleRandomAction(message);
                        break;
                    case 'update_participants':
                        updateParticipants(message);
                        break;
                    case 'parameter_update':
                        handleParameterUpdate(message);
                        break;
                    case 'list_items_update':
                        handleListItemsUpdate(message);
                        break;
                    case 'drawn_items_update':
                        handleDrawnItemsUpdate(message);
                        break;
                }
            };
            
            socket.onclose = function(event) {
                console.log('WebSocket connection closed with code:', event.code);
                isConnected = false;
                
                // Try to reconnect with exponential backoff
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    const delay = Math.min(1000 * Math.pow(1.5, reconnectAttempts), 10000);
                    reconnectAttempts++;
                    console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                    
                    setTimeout(connectWebSocket, delay);
                } else {
                    console.error('Maximum reconnection attempts reached. Please refresh the page.');
                    addLogEntry("Connection lost. Please refresh the page.");
                    
                    // Display connection error to user
                    const notification = document.createElement('div');
                    notification.className = 'parameter-update-notification';
                    notification.style.borderColor = '#f44336';
                    notification.innerHTML = `
                        <div class="notification-content">
                            <strong>Connection Error</strong>
                            <br>WebSocket connection lost.
                            <br>Please refresh the page to reconnect.
                        </div>
                        <button class="notification-close">√ó</button>
                    `;
                    
                    // Add close button functionality
                    const closeBtn = notification.querySelector('.notification-close');
                    closeBtn.addEventListener('click', () => {
                        notification.remove();
                    });
                    
                    // Add to the document
                    document.body.appendChild(notification);
                }
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                // Don't need to handle disconnect here - onclose will be called
            };
        }
        
        function updateParticipants(message) {
            users = message.users || [];
            updateUserDisplay();
            updateParticipantProgress();
        }
        
        // Handle join events
        function handleJoin(message) {
            console.log('Join event received:', message);
            users = message.users || [];
            updateUserDisplay();
            
            // Add to activity log
            if (message.user_id !== clientId) {
                addLogEntry({
                    timestamp: message.timestamp,
                    action: 'join',
                    user_id: message.user_id,
                    user_name: message.user_name || 'User'
                });
            }
        }
        
        // Handle user leave
        function handleLeave(message) {
            console.log('Leave event received:', message);
            users = message.users || [];
            updateUserDisplay();
            
            if (message.username) {
                addLogEntry(`${message.username} left the room`);
            }
        }
        
        // Handle name change
        function handleNameChange(message) {
            console.log('Name change event received:', message);
            users = message.users || [];
            updateUserDisplay();
            
            if (message.client_id !== clientId) {
                addLogEntry(`${message.old_name || 'User'} changed their name to ${message.new_name || 'User'}`);
            }
        }
        
        // Handle random action (coin flip or number draw)
        function handleRandomAction(message) {
            console.log('Random action received:', message);
            // Add log entry
            const actionText = `${message.username || 'User'} performed ${message.action?.toLowerCase() || 'action'}: ${message.result || ''}`;
            addLogEntry(actionText);
            
            // Perform animation
            if (message.action === 'Coin Flip' && isCoinFlip) {
                performCoinFlipAnimation(message.result);
            } else if (message.action === 'List Draw' && isListDraw) {
                performListDrawAnimation(message.result);
            } else if (message.action === 'Number Draw' && !isCoinFlip && !isListDraw) {
                performNumberDrawAnimation(message.result);
            }
        }
        
        // Handle parameter update event
        function handleParameterUpdate(message) {
            console.log('Parameter update received:', message);
            
            // Ignore if this is our own update
            if (message.client_id === clientId) {
                console.log('Ignoring own parameter update');
                return;
            }
            
            const params = message.parameters;
            if (!params) {
                console.error('Received parameter update without parameters');
                return;
            }
            
            console.log(`Updating parameters to: min=${params.min_value}, max=${params.max_value}, replacement=${params.with_replacement}`);
            
            // Create a notification element
            const notification = document.createElement('div');
            notification.className = 'parameter-update-notification';
            notification.innerHTML = `
                <div class="notification-content">
                    <strong>${message.username}</strong> changed draw settings:
                    <br>Range: ${params.min_value} - ${params.max_value}
                    <br>Replacement: ${params.with_replacement ? 'Yes' : 'No'}
                </div>
                <button class="notification-close">√ó</button>
            `;
            
            // Add close button functionality
            const closeBtn = notification.querySelector('.notification-close');
            closeBtn.addEventListener('click', () => {
                notification.remove();
            });
            
            // Auto-dismiss after 8 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('fade-out');
                    setTimeout(() => notification.remove(), 500);
                }
            }, 8000);
            
            // Add log entry
            addLogEntry(`${message.username} changed draw settings to ${params.min_value}-${params.max_value} (replacement: ${params.with_replacement ? 'Yes' : 'No'})`);
            
            try {
                // Update form values if in number draw mode and elements exist
                if (!isCoinFlip && !isListDraw) {
                    // These elements only exist in number draw mode
                    const minInput = document.getElementById('min-value');
                    const maxInput = document.getElementById('max-value');
                    const replaceCheckbox = document.getElementById('with-replacement');
                    
                    if (minInput && maxInput && replaceCheckbox) {
                        console.log('Updating form fields with new parameters');
                        minInput.value = params.min_value;
                        maxInput.value = params.max_value;
                        replaceCheckbox.checked = params.with_replacement;
                    } else {
                        console.warn('Form elements not found for parameter update');
                    }
                }
            } catch (error) {
                console.error('Error updating form fields:', error);
            }
            
            // Add to the document
            document.body.appendChild(notification);
        }
        
        // Handle list items update from other clients
        function handleListItemsUpdate(message) {
            // Skip if this is our own update or not in list draw mode
            if (message.client_id === clientId || !isListDraw) return;
            
            console.log('List items update received:', message);
            
            // Update the list items textarea if it exists
            if (listItemsTextarea) {
                // Update the textarea only if it's empty or user hasn't interacted with it
                if (listItemsTextarea.value.trim() === '') {
                    listItemsTextarea.value = message.list_items.join('\n');
                    // Also update our local list items array
                    listItems = message.list_items;
                    
                    // Add notification
                    const notification = document.createElement('div');
                    notification.className = 'parameter-update-notification';
                    notification.innerHTML = `
                        <div class="notification-content">
                            <strong>${message.username}</strong> updated the list items.
                        </div>
                        <button class="notification-close">√ó</button>
                    `;
                    
                    // Add close button functionality
                    const closeBtn = notification.querySelector('.notification-close');
                    closeBtn.addEventListener('click', () => { notification.remove(); });
                    
                    // Auto-dismiss after 5 seconds
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.classList.add('fade-out');
                            setTimeout(() => notification.remove(), 500);
                        }
                    }, 5000);
                    
                    // Add to the document
                    document.body.appendChild(notification);
                    
                    // Add to activity log
                    addLogEntry(`${message.username} updated the list items`);
                } else {
                    console.log('Not updating textarea as user has entered custom items');
                }
            }
        }
        
        // Handle drawn items update
        function handleDrawnItemsUpdate(message) {
            // Skip if not in list draw mode
            if (!isListDraw) return;
            
            console.log('Drawn items update received:', message);
            
            // Update our local drawn items array
            drawnItems = message.drawn_items;
        }
        
        // Update user display
        function updateUserDisplay() {
            // Update count
            userCountElement.textContent = users.length;
            
            // Update user pills
            userPillsElement.innerHTML = '';
            users.forEach(user => {
                const pill = document.createElement('div');
                pill.className = 'user-pill';
                if (user.client_id === clientId) {
                    pill.className += ' current-user';
                }
                pill.textContent = user.username || 'User';
                userPillsElement.appendChild(pill);
            });
            
            // Update participant progress
            updateParticipantProgress();
        }
        
        // Add log entry
        function addLogEntry(text, timestamp = new Date().toISOString()) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            
            const formattedTime = new Date(timestamp).toLocaleTimeString();
            
            // Check if text is an object or string
            let logText = text;
            if (typeof text === 'object') {
                if (text.action === 'demo_mode_activated') {
                    logText = 'You activated Demo Mode';
                } else if (text.action === 'demo_mode_deactivated') {
                    logText = 'You deactivated Demo Mode';
                } else {
                    // For other object-based logs
                    logText = `${text.user_name || 'User'} ${text.action || 'performed an action'}`;
                }
            }
            
            logEntry.innerHTML = `
                <span class="log-time">${formattedTime}</span>
                <span class="log-text">${logText}</span>
            `;
            
            activityLog.insertBefore(logEntry, activityLog.firstChild);
        }
        
        // Load logs from the server
        async function loadLogs() {
            if (isLoadingLogs || !hasMoreLogs) return;
            
            isLoadingLogs = true;
            
            try {
                const response = await fetch(`/room/${roomId}/logs?page=${page}`);
                const data = await response.json();
                
                if (data.logs.length === 0) {
                    hasMoreLogs = false;
                } else {
                    // Add logs to the display
                    data.logs.forEach(log => {
                        const logText = `${log.user_name} performed ${log.action.toLowerCase()}: ${log.result}`;
                        addLogEntry(logText, log.timestamp);
                    });
                    
                    page++;
                }
            } catch (error) {
                console.error('Error loading logs:', error);
            } finally {
                isLoadingLogs = false;
            }
        }
        
        // Copy room URL to clipboard
        copyUrlBtn.addEventListener('click', () => {
            roomUrlInput.select();
            document.execCommand('copy');
            
            copyUrlBtn.textContent = 'Copied!';
            setTimeout(() => {
                copyUrlBtn.textContent = 'Copy URL';
            }, 2000);
        });
        
        {% if room.is_coin_flip %}
            // Coin flip animation
            function performCoinFlipAnimation(result) {
                coinElement.className = 'coin';
                void coinElement.offsetWidth; // Force reflow
                
                coinElement.className = 'coin coin-' + (result === 'Heads' ? 'heads' : 'tails');
            }
            
            // Handle coin flip button
            flipCoinBtn.addEventListener('click', () => {
                if (isConnected) {
                    socket.send(JSON.stringify({
                        type: 'coin_flip'
                    }));
                }
            });
        {% elif room.is_list_draw %}
            // List draw animation is handled in the section above
        {% else %}
            // Number draw animation
            function performNumberDrawAnimation(result) {
                numberDisplay.className = 'number-display';
                void numberDisplay.offsetWidth; // Force reflow
                
                numberDisplay.textContent = result;
                numberDisplay.className = 'number-display number-reveal';
            }
            
            // Handle number draw button
            drawNumberBtn.addEventListener('click', () => {
                if (isConnected) {
                    // Send only one message with draw request containing parameters
                    socket.send(JSON.stringify({
                        type: 'number_draw',
                        min_value: parseInt(minValueInput.value),
                        max_value: parseInt(maxValueInput.value),
                        with_replacement: withReplacementCheckbox.checked
                    }));
                }
            });
        {% endif %}
        
        // Infinite scroll for logs
        activityLog.addEventListener('scroll', () => {
            if (activityLog.scrollTop + activityLog.clientHeight >= activityLog.scrollHeight - 50) {
                loadLogs();
            }
        });
        
        // Connect to WebSocket when page loads
        window.addEventListener('DOMContentLoaded', function() {
            console.log('Connecting to WebSocket...');
            connectWebSocket();
            
            // Send a heartbeat every 20 seconds to keep the connection alive
            const heartbeatInterval = setInterval(function() {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    console.log('Sending heartbeat ping');
                    socket.send(JSON.stringify({
                        type: 'heartbeat',
                        client_id: clientId
                    }));
                } else if (!isConnected) {
                    console.log('Socket not connected during heartbeat check');
                }
            }, 20000); // Reduced from 30s to 20s for Heroku
            
            // Clean up on page unload (tab close or navigation away)
            window.addEventListener('beforeunload', function() {
                console.log('Page unloading, cleaning up WebSocket connection');
                // Clear heartbeat interval
                clearInterval(heartbeatInterval);
                
                // Send disconnect message if connected
                if (socket && socket.readyState === WebSocket.OPEN) {
                    // Use sendBeacon for more reliable delivery during page unload
                    const disconnectMsg = JSON.stringify({
                        type: 'disconnect',
                        client_id: clientId
                    });
                    
                    try {
                        // Try to use the WebSocket first
                        socket.send(disconnectMsg);
                        
                        // As a backup, also try to use navigator.sendBeacon with a POST request
                        // This is more likely to complete during page unload
                        const blob = new Blob([disconnectMsg], { type: 'application/json' });
                        navigator.sendBeacon(`/api/disconnect?room_id=${roomId}&client_id=${clientId}`, blob);
                    } catch (e) {
                        console.error('Error during disconnect:', e);
                    }
                    
                    // Close the WebSocket connection
                    socket.close();
                }
            });
        });
        
        // Function to fetch statistics and update counters
        async function updateStats() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                
                // Update room counter with added value to make it look more popular
                updateCounter('roomsCounter', data.rooms_created + 2000);
                
                // Update draws counter with added value to make it look more popular
                updateCounter('drawsCounter', data.draws_performed + 2000);
            } catch (error) {
                console.error('Error fetching stats:', error);
            }
        }
        
        // Function to update counter display
        function updateCounter(elementId, value) {
            const counterEl = document.getElementById(elementId);
            counterEl.innerHTML = '';
            
            // Convert value to string and pad with leading zeros
            const valueStr = String(value).padStart(6, '0');
            
            // Create digit elements
            for (let i = 0; i < valueStr.length; i++) {
                const digit = document.createElement('div');
                digit.className = 'stats-digit';
                digit.textContent = valueStr[i];
                counterEl.appendChild(digit);
            }
        }
        
        // Fetch stats when page loads
        document.addEventListener('DOMContentLoaded', updateStats);
        
        // Update stats periodically (every 30 seconds)
        setInterval(updateStats, 30000);
    </script>
</body>
</html> 